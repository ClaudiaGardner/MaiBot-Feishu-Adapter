"""é£ä¹¦é•¿è¿æ¥äº‹ä»¶å®¢æˆ·ç«¯"""
import asyncio
import websockets
from websockets import ConnectionClosed
import json
import time
from typing import Optional
from src.logger import logger
from src.config import global_config
from src.feishu_client import feishu_client
from src.message_converter import process_feishu_message


class FeishuEventClient:
    """é£ä¹¦é•¿è¿æ¥äº‹ä»¶å®¢æˆ·ç«¯"""
    
    def __init__(self):
        self.ws: Optional[websockets.WebSocketClientProtocol] = None
        self.endpoint_url: Optional[str] = None
        self.should_reconnect = True
        self.ping_task: Optional[asyncio.Task] = None
    
    async def get_endpoint(self) -> str:
        """è·å–é•¿è¿æ¥ Endpoint"""
        import aiohttp
        
        # æ­£ç¡®çš„ API ç«¯ç‚¹ï¼šåˆ›å»ºé•¿è¿æ¥é…ç½®
        url = "https://open.feishu.cn/open-apis/im/v1/stream/get"
        headers = {
            "Authorization": f"Bearer {feishu_client.get_access_token()}",
            "Content-Type": "application/json"
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                # å…ˆæ£€æŸ¥çŠ¶æ€ç 
                if response.status != 200:
                    text = await response.text()
                    raise Exception(f"HTTP {response.status}: {text}")
                
                data = await response.json()
                
                if data.get("code") == 0:
                    endpoint = data["data"]["endpoint"]
                    logger.info(f"âœ… è·å–é•¿è¿æ¥ Endpoint æˆåŠŸ: {endpoint}")
                    return endpoint
                else:
                    # æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
                    error_msg = data.get("msg", "æœªçŸ¥é”™è¯¯")
                    error_code = data.get("code")
                    raise Exception(f"è·å– Endpoint å¤±è´¥ (code: {error_code}): {error_msg}")
    
    async def send_ping(self):
        """å‘é€å¿ƒè·³åŒ…"""
        while self.ws and not self.ws.closed:
            try:
                await self.ws.send(json.dumps({"type": "PING"}))
                logger.debug("ğŸ’“ å‘é€å¿ƒè·³åŒ…")
                await asyncio.sleep(30)  # æ¯ 30 ç§’å‘é€ä¸€æ¬¡
            except Exception as e:
                logger.error(f"âŒ å‘é€å¿ƒè·³å¤±è´¥: {e}")
                break
    
    async def handle_event(self, event_data: dict):
        """å¤„ç†äº‹ä»¶"""
        event_type = event_data.get("type")
        
        if event_type == "PONG":
            logger.debug("ğŸ’š æ”¶åˆ°å¿ƒè·³å“åº”")
            return
        
        if event_type == "EVENT_CALLBACK":
            # å¤„ç†äº‹ä»¶å›è°ƒ
            event = event_data.get("event", {})
            header = event_data.get("header", {})
            
            event_type_name = header.get("event_type")
            logger.info(f"ğŸ“¨ æ”¶åˆ°äº‹ä»¶: {event_type_name}")
            
            # å¤„ç†æ¶ˆæ¯äº‹ä»¶
            if event_type_name == "im.message.receive_v1":
                await self.handle_message_event(event)
            else:
                logger.warning(f"âš ï¸ æœªå¤„ç†çš„äº‹ä»¶ç±»å‹: {event_type_name}")
    
    async def handle_message_event(self, event: dict):
        """å¤„ç†æ¶ˆæ¯äº‹ä»¶"""
        try:
            # æ„é€ ä¸ Webhook ç›¸åŒçš„æ¶ˆæ¯ç»“æ„
            message_data = {
                "event": event
            }
            
            # ä½¿ç”¨ç°æœ‰çš„æ¶ˆæ¯è½¬æ¢å™¨å¤„ç†
            await process_feishu_message(message_data)
            
        except Exception as e:
            logger.error(f"âŒ å¤„ç†æ¶ˆæ¯äº‹ä»¶å¤±è´¥: {e}", exc_info=True)
    
    async def connect(self):
        """è¿æ¥åˆ°é£ä¹¦é•¿è¿æ¥æœåŠ¡"""
        retry_count = 0
        max_retries = 5
        
        while self.should_reconnect and retry_count < max_retries:
            try:
                # è·å– Endpoint
                if not self.endpoint_url:
                    self.endpoint_url = await self.get_endpoint()
                
                logger.info(f"ğŸ”— æ­£åœ¨è¿æ¥é£ä¹¦é•¿è¿æ¥æœåŠ¡...")
                
                # å»ºç«‹ WebSocket è¿æ¥
                async with websockets.connect(
                    self.endpoint_url,
                    ping_interval=None,  # æˆ‘ä»¬è‡ªå·±å¤„ç†å¿ƒè·³
                    ping_timeout=None,
                    close_timeout=10
                ) as ws:
                    self.ws = ws
                    logger.info("âœ… é£ä¹¦é•¿è¿æ¥å·²å»ºç«‹")
                    retry_count = 0  # é‡ç½®é‡è¯•è®¡æ•°
                    
                    # å¯åŠ¨å¿ƒè·³ä»»åŠ¡
                    self.ping_task = asyncio.create_task(self.send_ping())
                    
                    # ç›‘å¬æ¶ˆæ¯
                    async for message in ws:
                        try:
                            data = json.loads(message)
                            await self.handle_event(data)
                        except json.JSONDecodeError as e:
                            logger.error(f"âŒ JSON è§£æå¤±è´¥: {e}")
                        except Exception as e:
                            logger.error(f"âŒ å¤„ç†äº‹ä»¶å¤±è´¥: {e}", exc_info=True)
                
            except ConnectionClosed as e:
                logger.warning(f"âš ï¸ è¿æ¥å·²å…³é—­: {e}")
                self.ws = None
                self.endpoint_url = None  # é‡æ–°è·å– Endpoint
                
                if self.should_reconnect:
                    retry_count += 1
                    wait_time = min(2 ** retry_count, 60)  # æŒ‡æ•°é€€é¿ï¼Œæœ€å¤š 60 ç§’
                    logger.info(f"ğŸ”„ {wait_time} ç§’åé‡è¿... (å°è¯• {retry_count}/{max_retries})")
                    await asyncio.sleep(wait_time)
                else:
                    break
                    
            except Exception as e:
                logger.error(f"âŒ è¿æ¥å¤±è´¥: {e}", exc_info=True)
                self.ws = None
                self.endpoint_url = None
                
                if self.should_reconnect:
                    retry_count += 1
                    wait_time = min(2 ** retry_count, 60)
                    logger.info(f"ğŸ”„ {wait_time} ç§’åé‡è¿... (å°è¯• {retry_count}/{max_retries})")
                    await asyncio.sleep(wait_time)
                else:
                    break
        
        if retry_count >= max_retries:
            logger.error("âŒ è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒé‡è¿")
    
    async def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        self.should_reconnect = False
        
        if self.ping_task:
            self.ping_task.cancel()
            try:
                await self.ping_task
            except asyncio.CancelledError:
                pass
        
        if self.ws and not self.ws.closed:
            await self.ws.close()
            logger.info("ğŸ”Œ å·²æ–­å¼€é£ä¹¦é•¿è¿æ¥")


# å…¨å±€å®ä¾‹
feishu_event_client = FeishuEventClient()
